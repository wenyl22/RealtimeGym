from realtimegym.environments.overcooked import Recipe, orientation_to_char_mapping
from copy import deepcopy

SLOW_AGENT_PROMPT = """
Help Alice collaborate with Bob in *Overcooked* to maximize the total reward from delivered soup recipes. Optimize coordination, planning, and decision-making based on the current game state and action history of both players.
---
### **Game Rules & Mechanics**
#### **1. Game Grid (2D Tile Types)**
- **Empty Tile:** Walkable space.
- **Dispensers:** Sources for items (tomato/onion/clean plate).
- **Pot:** Cooks soup (3 ingredients → auto-starts cooking).
- **Serving Counter:** Deliver cooked soup for rewards.
- **Kitchen Counter:** Temporary item storage.

#### **2. Player Actions per Turn**
Each player (Alice/Bob) can:
- **Move** (L/R/U/D): Changes position *and* orientation. Specifically, L (x-1, y), R (x+1, y), U (x, y+1), D (x, y-1).
- **Change Orientation** (L/R/U/D): No move if the adjacent tile is not an empty one.
- **Interact (I):** Player can interact with a non-empty tile if it is 1) standing on an empty tile adjacent to the tile and 2) facing the tile. Interact effects depend on game state and tile type:
  - **Dispensers:** Grab item (if player is empty-handed).
  - **Pot:**
    - Add ingredient (if pot is not full and player is holding ingredient) → cooks automatically at 3 ingredients.
    - Serve soup (if player is holding a clean plate and pot has cooked soup).
  - **Serving Counter:** Deliver soup (if player is holding a soup in plate).
  - **Kitchen Counter:** Pick up items (if player is empty-handed and counter is occupied) or place items (if player is holding an item and counter is empty).
- **Stay (S):** Do nothing.

#### **3. Key Constraints**
- Players can carry **one item at a time**.
- Players cannot walk onto/through each other.
- Players cannot walk onto/through non-empty tiles.

#### **4. Recipes & Rewards**
- Each recipe requires different ingredients, cooking time, and yields varying rewards.
- Cooking time is 20 turns if ingredients do not match any recipe in the order, and serving the recipe does not yield rewards.
---

### **Your Task**
At turn \\( t_1 \\), plan a sequence of actions \\(\\{a_{t_1 + t}\\}_{t=1}^{H-1}\\) for Alice (and optionally Bob) over next several turns(say, H turns) to maximize total reward from delivered recipes.

"""

ACTION_FORMAT_PROMPT = """
**Answer Format**:

\\boxed{
Turn t_1: a_\\{t_1\\}
Turn t_1 + 1: a_\\{t_1 + 1\\}
...
}

Where each action \\(a_t \\in \\{U, D, L, R, I, S\\}\\).
"""

CONCLUSION_FORMAT_PROMPT = """
**Answer Format**:

Your answer **must** include both of the following, clearly separated:

**(1) Action Sequence (in order):**

\\boxed{
Turn t_1: a_\\{t_1\\}
Turn t_1 + 1: a_\\{t_1 + 1\\}
...
}

Where each action \\(a_t \\in \\{U, D, L, R, I, S\\}\\).

**(2) Main Thinking Conclusion (one or two sentences):**

A concise summary explaining the main decision strategy behind your chosen sequence.
"""

FAST_AGENT_PROMPT = """
Help Alice collaborate with Bob in *Overcooked* to maximize the total reward from delivered soup recipes. You need to decide the immediate action for the current Turn \\(t_0\\) based on:
1. Current game state and action history of both players.
2. Thinking model's past plan. Sometimes you may be given a plan generated by a thinking model at turn \\(t_1 \\leq t_0\\), which might be outdated or inaccurate, but it can still provide useful information for your decision making. You can take it as a **strategic reference**, not a mandatory instruction.

### **Game Rules & Mechanics**
#### **1. Game Grid (2D Tile Types)**
- **Empty Tile:** Walkable space.
- **Dispensers:** Sources for items (tomato/onion/clean plate).
- **Pot:** Cooks soup (3 ingredients → auto-starts cooking).
- **Serving Counter:** Deliver cooked soup for rewards.
- **Kitchen Counter:** Temporary item storage.

#### **2. Player Actions per Turn**
Each player (Alice/Bob) can:
- **Move** (L/R/U/D): Changes position *and* orientation. Specifically, L (x-1, y), R (x+1, y), U (x, y+1), D (x, y-1).
- **Change Orientation** (L/R/U/D): No move if the adjacent tile is not an empty one.
- **Interact (I):** Player can interact with a non-empty tile if it is 1) standing on an empty tile adjacent to the tile and 2) facing the tile. Interact effects depend on game state and tile type:
  - **Dispensers:** Grab item (if player is empty-handed).
  - **Pot:**
    - Add ingredient (if pot is not full and player is holding ingredient) → cooks automatically at 3 ingredients.
    - Serve soup (if player is holding a clean plate and pot has cooked soup).
  - **Serving Counter:** Deliver soup (if player is holding a soup in plate).
  - **Kitchen Counter:** Pick up items (if player is empty-handed and counter is occupied) or place items (if player is holding an item and counter is empty).
- **Stay (S):** Do nothing.

#### **3. Key Constraints**
- Players can carry **one item at a time**.
- Players cannot walk onto/through each other.
- Players cannot walk onto/through non-empty tiles.

#### **4. Recipes & Rewards**
- Each recipe requires different ingredients, cooking time, and yields varying rewards.
- Cooking time is 20 turns if ingredients do not match any recipe in the order, and serving the recipe does not yield rewards.
---

### **Your Task**
Decide the immediate action \\(a_\\{t_0\\}\\) at turn \\(t_0\\) for Alice based on the current game state and the past plan from a thinking model at turn \\(t_1\\).

**Answer Format**:
\\boxed{a_{t_0}}

Where \\(a_{t_0} \\in \\{U, D, L, R, I, S\\}\\).
"""

GAME_STATE_PROMPT = """

## Environment Details

### Tile Types
    - Kitchen Counter: {kitchen_counter}
    - Tomato Dispenser: {tomato}
    - Onion Dispenser: {onion}
    - Plate Dispenser: {plate}
    - Pot: {pot}
    - Serving Counter: {serving_counter}

### Recipe Information
{recipe_infos}

## Current Game State

Game Turn: {t_format}

### Player Information
- **You (Alice)**
    - Position: {my_position}
    - Orientation: {my_orientation}
    - Holding: {my_holding}
    - Action History: {my_action_history}

- **Teammate (Bob)**
    - Position: {he_position}
    - Orientation: {he_orientation}
    - Holding: {he_holding}
    - Action History: {he_action_history}

Note: Action history is a list of actions taken by the player in the passed several turns(at most 5), with the most recent action listed at the end of the array.

### Non-empty Kitchen Counter
{kitchen_counter_state}
### Non-empty Pot State
{pot_state}
"""

ALL_ACTIONS = "UDLRIS"
DEFAULT_ACTION = "S"


def state_to_description(state_for_llm, mode=None):
    kitchen_counters = state_for_llm["layout"]["X"]
    tomatoes = state_for_llm["layout"]["T"]
    onions = state_for_llm["layout"]["O"]
    plates = state_for_llm["layout"]["D"]
    pots = state_for_llm["layout"]["P"]
    serving_counters = state_for_llm["layout"]["S"]
    recipe_infos = state_for_llm["all_orders"]
    text_recipe_infos = ""
    for i, recipe in enumerate(recipe_infos):
        ingredients = recipe["ingredients"]
        num_onions = len(
            [ingredient for ingredient in ingredients if ingredient == Recipe.ONION]
        )
        num_tomatoes = len(
            [ingredient for ingredient in ingredients if ingredient == Recipe.TOMATO]
        )
        reward = recipe["value"]
        time = recipe["time"]
        text_recipe_infos += f"Recipe {i + 1}: {num_onions} onions, {num_tomatoes} tomatoes; reward: {reward}; time to cook: {time} turns\n"
    position = [0, 0]
    orientation = [0, 0]
    held_object: list = [0, 0]
    history = [0, 0]
    for i in range(2):
        player = state_for_llm["state"]["players"][i]
        position[i] = player["position"]
        orientation[i] = orientation_to_char_mapping[player["orientation"]]
        held_object[i] = deepcopy(player["held_object"])
        if len(state_for_llm["history"][i]) > 0:
            history[i] = ", ".join(state_for_llm["history"][i])
        else:
            history[i] = "No action history"
        if held_object[i] is not None:
            held_object[i] = "one " + held_object[i]["name"]  # type: ignore
            if held_object[i] == "dish":
                held_object[i] = "clean plate"
            elif held_object[i] == "soup":
                held_object[i] = "soup in plate"
        else:
            held_object[i] = "nothing"
    pot_state = {}
    kitchen_counter_state = {}
    for soup in state_for_llm["state"]["objects"]:
        pot_id = soup["position"]
        if pot_id in kitchen_counters:
            kitchen_counter_state[pot_id] = (
                f"Kitchen Counter on {pot_id}: contains a {soup['name'].replace('dish', 'clean plate')}; "
            )
            continue
        if pot_id not in pots:
            assert pot_id in position, f"{pot_id} not in a valid spot"
            continue
        assert soup["name"] == "soup", f"Object {soup['name']} is not a soup."
        ingredients = soup["_ingredients"]
        assert (
            sum([ingredient["position"] != pot_id for ingredient in ingredients]) == 0
        ), f"No ingredients found in pot {pot_id}."
        ingredients = [ingredient["name"] for ingredient in ingredients]
        num_onions = len(
            [ingredient for ingredient in ingredients if ingredient == Recipe.ONION]
        )
        num_tomatoes = len(
            [ingredient for ingredient in ingredients if ingredient == Recipe.TOMATO]
        )
        if len(ingredients) == 0:
            ingredients = "nothing"
        else:
            ingredients = f"{num_onions} onions and {num_tomatoes} tomatoes"
        if soup["is_idle"]:
            state = "Pot is not full thus cooking hasn't started yet."
        elif soup["is_cooking"]:
            state = f"Cooked for {soup['cooking_tick']} turns, still need {soup['cook_time'] - soup['cooking_tick']} turns to finish."
        elif soup["is_ready"]:
            state = "Ready to serve."
        pot_state[pot_id] = f"Pot on {pot_id}: contains {ingredients}; {state}"
    text_kitchen_counter_state = "\n".join(kitchen_counter_state.values())
    if text_kitchen_counter_state == "":
        text_kitchen_counter_state = "All kitchen counters are empty."
    text_pot_state = "\n".join(pot_state.values())
    if text_pot_state == "":
        text_pot_state = "All pots are empty."
    game_turn = state_for_llm["game_turn"]

    model1_description = GAME_STATE_PROMPT.format(
        kitchen_counter=kitchen_counters,
        tomato=tomatoes if len(tomatoes) > 0 else "No tomato dispensers",
        onion=onions,
        plate=plates,
        pot=pots,
        serving_counter=serving_counters,
        recipe_infos=text_recipe_infos,
        t_format=f"t_0 = {game_turn}",
        my_position=position[0],
        my_orientation=orientation[0],
        my_holding=held_object[0],
        my_action_history=history[0],
        he_position=position[1],
        he_orientation=orientation[1],
        he_holding=held_object[1],
        he_action_history=history[1],
        kitchen_counter_state=text_kitchen_counter_state,
        pot_state=text_pot_state,
    )
    model2_description = GAME_STATE_PROMPT.format(
        kitchen_counter=kitchen_counters,
        tomato=tomatoes if len(tomatoes) > 0 else "No tomato dispensers",
        onion=onions,
        plate=plates,
        pot=pots,
        serving_counter=serving_counters,
        recipe_infos=text_recipe_infos,
        t_format=f"t_1 = {game_turn}",
        my_position=position[0],
        my_orientation=orientation[0],
        my_holding=held_object[0],
        my_action_history=history[0],
        he_position=position[1],
        he_orientation=orientation[1],
        he_holding=held_object[1],
        he_action_history=history[1],
        kitchen_counter_state=text_kitchen_counter_state,
        pot_state=text_pot_state,
    )
    if mode == "reactive":
        return FAST_AGENT_PROMPT + model1_description
    elif mode == "planning":
        return SLOW_AGENT_PROMPT + ACTION_FORMAT_PROMPT + model2_description
    elif mode == "agile":
        return {
            "planning": SLOW_AGENT_PROMPT
            + CONCLUSION_FORMAT_PROMPT
            + model2_description,
            "reactive": FAST_AGENT_PROMPT + model1_description,
        }
